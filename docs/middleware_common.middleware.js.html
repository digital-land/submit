<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: middleware/common.middleware.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: middleware/common.middleware.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// @ts-check
import logger from '../utils/logger.js'
import { types } from '../utils/logging.js'
import { entryIssueGroups } from '../utils/utils.js'
import performanceDbApi from '../services/performanceDbApi.js'
import { fetchMany, fetchOne, FetchOneFallbackPolicy, FetchOptions, renderTemplate } from './middleware.builders.js'
import * as v from 'valibot'
import { pagination } from '../utils/pagination.js'
import datasette from '../services/datasette.js'
import { errorTemplateContext, MiddlewareError } from '../utils/errors.js'
import { dataRangeParams } from '../routes/schemas.js'
import { isFeatureEnabled } from '../utils/features.js'

/**
 * Middleware. Set `req.handlerName` to a string that will identify
 * the function that threw the error.
 *
 * @param {Error} err - The error that was thrown
 * @param {Object} req - Express request object with handlerName property
 * @param {string} req.handlerName - Name of the handler function
 * @param {string} req.originalUrl - Original request URL
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware function
 */
export const logPageError = (err, req, res, next) => {
  console.assert(req.handlerName, 'handlerName missing ')
  logger.warn({
    message: `OrganisationsController.${req.handlerName}(): ${err.message}`,
    endpoint: req.originalUrl,
    errorStack: err.stack,
    errorMessage: err.message,
    type: types.App
  })
  next(err)
}

export const fetchDatasetInfo = fetchOne({
  query: ({ params }) => {
    return `SELECT name, dataset, collection FROM dataset WHERE dataset = '${params.dataset}'`
  },
  result: 'dataset'
})

/**
 * Was the resource accessed successfully via HTTP?
 *
 * @param {*} req
 * @returns {boolean}
 */
export const isResourceIdValid = (req) => req.resourceStatus.resource.trim() !== ''
export const isResourceIdInParams = ({ params }) => !('resourceId' in params)
export const isResourceDataPresent = (req) => 'resource' in req

export const and = (...args) => {
  return (req) => args.every(arg => arg(req))
}
export const or = (...args) => {
  return (req) => args.some(arg => arg(req))
}

/**
 * Middleware. Updates req with `resource`.
 */
export const fetchLatestResource = fetchOne({
  query: ({ params }) => performanceDbApi.latestResourceQuery(params.lpa, params.dataset),
  result: 'resource',
  fallbackPolicy: FetchOneFallbackPolicy.continue
})

export const takeResourceIdFromParams = (req) => {
  logger.debug('skipping resource fetch', { type: types.App, params: req.params })
  req.resource = { resource: req.params.resourceId }
}

export const fetchOrgInfo = fetchOne({
  query: ({ params }) => {
    return `SELECT name, organisation, entity, statistical_geography FROM organisation WHERE organisation = '${params.lpa}'`
  },
  result: 'orgInfo'
})

/**
 * Middleware. Validates query params according to schema.
 * Short circuits with 400 error if validation fails. Potentially updates req with `parsedParams`
 *
 * `this` needs: `{ schema }`
 *
 * @param {*} req
 * @param {*} res
 * @param {*} next
 */
export function validateQueryParamsFn (req, res, next) {
  try {
    req.parsedParams = v.parse(this.schema || v.any(), req.params)
    next()
  } catch (error) {
    const err = new MiddlewareError('Query params validation error', 400, { cause: error })
    res.status(err.statusCode).render(err.template, { ...errorTemplateContext(), err })
  }
}

export function validateQueryParams (context) {
  return validateQueryParamsFn.bind(context)
}

export const fetchLpaDatasetIssues = fetchMany({
  query: ({ params, req }) => performanceDbApi.datasetIssuesQuery(req.resourceStatus.resource, params.dataset),
  result: 'issues'
})

export const getDatasetTaskListError = renderTemplate({
  templateParams: (req) => req.templateParams,
  template: 'organisations/http-error.html',
  handlerName: 'getDatasetTaskListError'
})

export const show404IfPageNumberNotInRange = (req, res, next) => {
  const { dataRange } = req
  const { pageNumber } = req.parsedParams
  v.parse(dataRangeParams, dataRange)

  if (pageNumber > dataRange.maxPageNumber || pageNumber &lt; 1) {
    const error = new MiddlewareError(`page number ${pageNumber} not in range [1, ${dataRange.maxPageNumber}]`, 404)
    return next(error)
  }
  next()
}

export const createPaginationTemplateParams = (req, res, next) => {
  const { pageNumber } = req.parsedParams
  const { baseSubpath, dataRange } = req

  if (isNaN(pageNumber) || pageNumber &lt; 1) {
    const error = new Error('Invalid page number')
    return next(error)
  }

  if (dataRange.maxPageNumber &lt;= 1) {
    return next()
  }

  /**
   * @typedef {Object} PaginationItem
   * @property {'ellipsis'|'number'} type - Type of pagination item
   * @property {number} [number] - Page number (for number type)
   * @property {string} href - Link URL
   * @property {boolean} [ellipsis] - Whether this is an ellipsis item
   * @property {boolean} [current] - Whether this is the current page
   */

  /**
   * @typedef {Object} PaginationNav
   * @property {Object} [previous] - Previous page link
   * @property {string} previous.href - Previous page URL
   * @property {Object} [next] - Next page link
   * @property {string} next.href - Next page URL
   * @property {PaginationItem[]} items - Pagination items
   */

  /** @type {PaginationNav} */
  const paginationObj = {
    previous: undefined,
    next: undefined,
    items: []
  }

  if (pageNumber > 1) {
    paginationObj.previous = {
      href: `${baseSubpath}/${pageNumber - 1}`
    }
  }
  if (pageNumber &lt; dataRange.maxPageNumber) {
    paginationObj.next = {
      href: `${baseSubpath}/${pageNumber + 1}`
    }
  }

  for (const item of pagination(dataRange.maxPageNumber, Math.min(pageNumber, dataRange.maxPageNumber))) {
    if (item === '...') {
      paginationObj.items.push({
        type: 'ellipsis',
        ellipsis: true,
        href: '#'
      })
    } else if (typeof item === 'number') {
      paginationObj.items.push({
        type: 'number',
        number: item,
        href: `${baseSubpath}/${item}`,
        current: pageNumber === item
      })
    } else {
      logger.warn('unexpected pagination item', { item, dataRange, types: types.App, endpoint: req.originalUrl })
    }
  }

  req.pagination = paginationObj

  next()
}

// Resources

export const fetchResources = fetchMany({
  query: ({ req }) => {
    const lpaClause = req.params.lpa ? `AND ro.organisation = '${req.params.lpa}'` : ''
    const datasetClause = req.params.dataset ? `AND rd.dataset = '${req.params.dataset}'` : ''
    return `
      SELECT DISTINCT  s.documentation_url, r.start_date as resource_start_date, r.end_date, r.entry_date, r.mime_type, r.resource, r.start_date, rd.dataset, rhe.endpoint_url, rhe.licence, rhe.status, rhe.latest_log_entry_date, rhe.endpoint_entry_date from resource r
      LEFT JOIN resource_organisation ro ON ro.resource = r.resource
      LEFT JOIN resource_dataset rd ON rd.resource = r.resource
      LEFT JOIN reporting_historic_endpoints rhe ON r.resource = rhe.resource
      LEFT JOIN source s ON s.endpoint = rhe.endpoint_url
      WHERE r.end_date = ''
      ${lpaClause}
      ${datasetClause}
      ORDER BY r.start_date desc`
  },
  result: 'resources'
})

export const addEntityCountsToResources = async (req, res, next) => {
  const { resources } = req

  const promises = resources.map(resource => {
    const query = `SELECT entry_count FROM dataset_resource WHERE resource = "${resource.resource}"`
    return datasette.runQuery(query, resource.dataset)
  })

  try {
    const datasetResources = await Promise.all(promises).catch(error => {
      logger.error('Failed to fetch dataset resources', { type: types.DataFetch, errorMessage: error.message, errorStack: error.stack })
      throw error
    })

    req.resources = resources.map((resource, i) => {
      return { ...resource, entry_count: datasetResources[i]?.formattedData[0]?.entry_count ?? 0 }
    })

    next()
  } catch (error) {
    logger.error('Error in addEntityCountsToResources', { type: types.App, errorMessage: error.message, errorStack: error.stack })
    next(error)
  }
}

// Specification

export const fetchSpecification = fetchOne({
  query: ({ req }) => `select * from specification WHERE specification = '${req.dataset.collection}'`,
  result: 'specification'
})

export const pullOutDatasetSpecification = (req, res, next) => {
  const { specification } = req
  let collectionSpecifications
  try {
    collectionSpecifications = JSON.parse(specification.json)
  } catch (error) {
    logger.error('Invalid JSON in specification.json', { error })
    return next(new Error('Invalid specification format'))
  }
  const datasetSpecification = collectionSpecifications.find((spec) => spec.dataset === req.dataset.dataset)
  if (!datasetSpecification) {
    logger.error('Dataset specification not found', { dataset: req.dataset.dataset })
    return next(new MiddlewareError('Dataset specification not found', 404))
  }
  req.specification = datasetSpecification
  next()
}

export const replaceUnderscoreInSpecification = (req, res, next) => {
  req.specification.fields = req.specification.fields.map((spec) => {
    if (spec.datasetField) {
      spec.datasetField = spec.datasetField.replace(/_/g, '-')
    }
    return spec
  })

  next()
}

export const fetchFieldMappings = fetchMany({
  query: () => 'select * from transform',
  result: 'fieldMappings'
})

export const addDatabaseFieldToSpecification = (req, res, next) => {
  const { specification, fieldMappings } = req

  req.specification.fields = specification.fields.flatMap(fieldObj => {
    if (['GeoX', 'GeoY'].includes(fieldObj.field)) { // special case for brownfield land
      return { datasetField: 'point', ...fieldObj }
    }

    const fieldMappingsForField = fieldMappings.filter(mapping => mapping.field === fieldObj.field)

    const datasetFields = fieldMappingsForField.map(mapping => mapping.replacement_field).filter(Boolean)

    if (datasetFields.length === 0) {
      // no dataset fields found, add the field anyway with datasetField set to the same value as fieldObj.field
      return { datasetField: fieldObj.field, ...fieldObj }
    }

    // sometimes a field maps to more than one dataset field, so we need to account for that
    const specificationEntriesWithDatasetFields = datasetFields.map(datasetField => ({ datasetField, ...fieldObj }))
    return specificationEntriesWithDatasetFields
  })

  next()
}

export const getUniqueDatasetFieldsFromSpecification = (req, res, next) => {
  const { specification } = req

  if (!specification) {
    throw new Error('specification is required')
  }

  req.uniqueDatasetFields = [...new Set(specification.fields.map(field => field.datasetField))]

  next()
}

/**
 * @name processSpecificationMiddleware
 * @function
 * @description Middleware chain to process the dataset specification and prepare it for the issue table
 */
export const processSpecificationMiddlewares = [
  fetchSpecification,
  pullOutDatasetSpecification,
  replaceUnderscoreInSpecification,
  fetchFieldMappings,
  addDatabaseFieldToSpecification,
  getUniqueDatasetFieldsFromSpecification
]

// Entities

export const fetchEntities = fetchMany({
  query: ({ req }) => `
    SELECT * FROM entity e
    WHERE e.organisation_entity = ${req.orgInfo.entity}`,
  dataset: FetchOptions.fromParams,
  result: 'entities'
})

export const extractJsonFieldFromEntities = (req, res, next) => {
  const { entities } = req
  if (!Array.isArray(entities)) {
    logger.error('Invalid entities array', { entities })
    return next(new Error('Invalid entities format'))
  }

  let numEntitiesWithNoJson = 0
  req.entities = entities.map(entity => {
    const jsonField = entity.json
    if (!jsonField || jsonField === '') {
      numEntitiesWithNoJson += 1
      return entity
    }
    entity.json = undefined
    try {
      const parsedJson = JSON.parse(jsonField)
      entity = Object.assign({}, parsedJson, entity)
    } catch (err) {
      logger.warn('common.middleware/extractJsonField: Error parsing JSON',
        { type: types.App, json: jsonField, entity: entity.entity, errorMessage: err.message })
    }
    return entity
  })

  if (numEntitiesWithNoJson > 0) {
    logger.info(`Got ${numEntitiesWithNoJson} entities with no json field`,
      { type: types.App, endpoint: req.originalUrl })
  }

  next()
}

export const replaceUnderscoreInEntities = (req, res, next) => {
  if (!req.entities) {
    next()
    return
  }

  req.entities = req.entities.map((entity) => {
    return Object.keys(entity).reduce((acc, key) => {
      const newKey = key.replace(/_/g, '-')
      acc[newKey] = entity[key]
      return acc
    }, {})
  })

  next()
}

/**
 * @name processEntitiesMiddleware
 * @function
 * @description Middleware chain to process entities and prepare them for the issue table
 */
export const processEntitiesMiddlewares = [
  fetchEntities,
  extractJsonFieldFromEntities,
  replaceUnderscoreInEntities
]

export const filterOutEntitiesWithoutIssues = (req, res, next) => {
  const { entities, issues } = req

  req.issueEntities = entities.filter(entity => {
    return issues.findIndex(issue => issue.entity === entity.entity) >= 0
  })

  next()
}

// entity issues

const fetchEntityIssuesForFieldAndType = fetchMany({
  query: ({ req, params }) => {
    const issueTypeClause = params.issue_type ? `AND i.issue_type = '${params.issue_type}'` : ''
    const issueFieldClause = params.issue_field ? `AND field = '${params.issue_field}'` : ''
    return `
        select i.issue_type, field, entity, message, severity, value
        from issue i
        LEFT JOIN issue_type it ON i.issue_type = it.issue_type
        WHERE resource in ('${req.resources.map(resource => resource.resource).join("', '")}')
        ${issueTypeClause}
        AND it.responsibility = 'external'
        AND it.severity = 'error'
        ${issueFieldClause}
        AND i.dataset = '${req.params.dataset}'
        AND entity != ''
        `
    // LIMIT ${req.dataRange.pageLength} OFFSET ${req.dataRange.offset}
  },
  result: 'issues'
})

export const removeIssuesThatHaveBeenFixed = async (req, res, next) => {
  const { issues, resources } = req

  if (!resources || resources.length &lt;= 0) {
    logger.warn('no resources provided for removeIssueThatHaveBeenFixed')
    return next()
  }

  // get all more recent facts for each issue
  const promises = issues
    .filter(issue => issue.resource !== resources[0].resource)
    .map((issue) => {
      const resourceIndex = resources.findIndex(resource => resource.resource === issue.resource)
      const newerResources = resourceIndex >= 0 ? resources.slice(0, resourceIndex) : resources

      return datasette.runQuery(`
        SELECT * FROM fact f
        LEFT JOIN fact_resource fr ON f.fact = fr.fact
        WHERE entity = ${issue.entity}
        AND field = '${issue.field}'
        AND fr.resource IN ('${newerResources.map(resource => resource.resource).join("','")}')
        ORDER BY fr.start_date desc
        LIMIT 1`,
      issue.dataset
      )
    })

  Promise.allSettled(promises).then((results) => {
  // results is an array of objects with status (fulfilled or rejected) and value or reason
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        if (result.value.formattedData.length > 0) {
          req.issues = req.issues.filter(issue => (issue.entity !== result.value.formattedData[0].entity || issue.field !== result.value.formattedData[0].field))
        }
      } else {
        logger.warn('request to datasette failed', {
          error: result.reason,
          stack: result.reason.stack
        })
      }
    })

    return next()
  }).catch(error => {
    logger.warn('Error in middleware, could not process promise array', {
      error
    })
    return next(error)
  })
}

// some field mappings aren't in our database, so we should add them here
const customFieldMappings = [
  {
    field: 'GeoX,GeoY',
    replacement_field: 'point'
  }
]
export const addCustomFieldMappings = (req, res, next) => {
  const { fieldMappings } = req

  req.fieldMappings = [...fieldMappings, ...customFieldMappings]
  next()
}

export const addFieldMappingsToIssue = (req, res, next) => {
  const { issues, fieldMappings } = req

  if (!issues) {
    logger.warn('no issues provided to addFieldMappingsToIssues')
    return next()
  }

  if (!fieldMappings) {
    logger.warn('no fieldMappings provided to addFieldMappingsToIssues')
    return next()
  }

  req.issues = issues.map(issue => {
    return {
      ...issue,
      replacement_field: fieldMappings.find(mapping => mapping.field === issue.field)?.replacement_field
    }
  })

  next()
}

// We can only get the issues without entity from the latest resource as we have no way of knowing if those in previous resources have been fixed?
export const fetchEntryIssues = fetchMany({
  query: ({ req, params }) => {
    const issueTypeClause = params.issue_type ? `AND i.issue_type = '${params.issue_type}'` : ''
    const issueFieldClause = params.issue_field ? `AND field = '${params.issue_field}'` : ''
    return `
      select i.issue_type, field, entity, message, severity, value, line_number
      from issue i
      LEFT JOIN issue_type it ON i.issue_type = it.issue_type
      WHERE resource = '${req.resources[0].resource}'
      ${issueTypeClause}
      AND it.responsibility = 'external'
      AND it.severity = 'error'
      AND i.dataset = '${req.params.dataset}'
      ${issueFieldClause}
      AND (entity = '' OR entity is NULL OR i.issue_type in ('${entryIssueGroups.map(issue => issue.type).join("', '")}'))
      LIMIT ${req.dataRange.pageLength} OFFSET ${req.dataRange.offset}
    `
  },
  result: 'entryIssues'
})

export const fetchEntityIssueCounts = fetchMany({
  query: ({ req }) => {
    const datasetClause = req.params.dataset ? `AND i.dataset = '${req.params.dataset}'` : ''
    return `
      select dataset, field, i.issue_type, COUNT(resource+line_number) as count
      from issue i
      LEFT JOIN issue_type it ON i.issue_type = it.issue_type
      WHERE resource in ('${req.resources.map(resource => resource.resource).join("', '")}')
      AND (entity != '' AND entity IS NOT NULL)
      AND it.responsibility = 'external'
      AND it.severity = 'error'
      ${datasetClause}
      GROUP BY field, i.issue_type, dataset
    `
  },
  result: 'entityIssueCounts'
})

export const getMostRecentResources = (resources) => {
  const mostRecentResourcesMap = {}
  resources.forEach(resource => {
    const currentRecent = mostRecentResourcesMap[resource.dataset]
    if (!currentRecent || new Date(currentRecent.start_date).getTime() &lt; new Date(resource.start_date).getTime()) {
      mostRecentResourcesMap[resource.dataset] = resource
    }
  })
  return Object.values(mostRecentResourcesMap)
}

export const fetchEntryIssueCounts = fetchMany({
  query: ({ req }) => {
    const datasetClause = req.params.dataset ? `AND i.dataset = '${req.params.dataset}'` : ''

    const mostRecentResources = getMostRecentResources(req.resources)

    const resourceIds = Object.values(mostRecentResources).map(resource => resource.resource)

    return `
      select dataset, field, i.issue_type, COUNT(resource + line_number) as count
      from issue i
      LEFT JOIN issue_type it ON i.issue_type = it.issue_type
      WHERE resource in ('${resourceIds.join("', '")}')
      AND (entity = '' OR entity is NULL)
      AND it.responsibility = 'external'
      AND it.severity = 'error'
      ${datasetClause}
      GROUP BY field, i.issue_type, dataset
    `
  },
  result: 'entryIssueCounts'
})

/**
 * This middleware chain is responsible for retrieving all entities for the given organisation, their latest issues,
 * filtering out issues that have been fixed, and constructing the table params.
 *
 * @required {object} orgInfo - The orgInfo obtained by fetchOrgInfo middleware
 * @required {string} resources - Array of resources, obtained by fetchResources middleware
 *
 * @memberof IssueTableMiddleware
 * @name getRelevantIssues
 * @function
 * @returns {array} An array of middleware functions that construct the necessary data for all the relevant issues.
 */
export const processRelevantIssuesMiddlewares = [
  fetchEntityIssuesForFieldAndType,
  // arguably removeIssuesThatHaveBeenFixed should be s step however we have only currently found one organisation,
  // however this step is very time consuming, so in order to progress im commenting it out for now
  // removeIssuesThatHaveBeenFixed,
  fetchFieldMappings,
  addCustomFieldMappings,
  addFieldMappingsToIssue
]

// Other

export const setDefaultParams = (req, res, next) => {
  if (!req.parsedParams) {
    return next()
  }

  Object.keys(req.parsedParams).forEach((key) => {
    req.params[key] = req.parsedParams[key]
  })

  next()
}

export const getSetBaseSubPath = (additionalParts = []) => (req, res, next) => {
  const params = [
    req.params.lpa,
    req.params.dataset,
    req.params.issue_type,
    req.params.issue_field,
    ...additionalParts.map(encodeURIComponent)
  ]

  req.baseSubpath = params.reduce(
    (path, param) => (param ? `${path}/${param}` : path),
    '/organisations'
  )
  next()
}

/**
 * @param {number} pageLength
 * @returns {Function} Express middleware function
 */
export const getSetDataRange = (pageLength) => {
  v.parse(v.pipe(v.number(), v.integer(), v.minValue(1)), pageLength)

  return (req, res, next) => {
    const { pageNumber } = req.parsedParams

    let recordCount = req.recordCount
    if (typeof recordCount !== 'number' || recordCount &lt; 0) {
      logger.warn(`Invalid record count: ${recordCount}`, { type: types.App, recordCount, endpoint: req.originalUrl })
      recordCount = 0
    }

    req.dataRange = v.parse(dataRangeParams, {
      minRow: (pageNumber - 1) * pageLength,
      maxRow: Math.min((pageNumber - 1) * pageLength + pageLength, recordCount),
      totalRows: recordCount,
      // pageNumber starts with 1, so we maxPageNumber to start with 1
      maxPageNumber: Math.max(Math.ceil(recordCount / pageLength), 1),
      pageLength,
      offset: (pageNumber - 1) * pageLength
    })

    next()
  }
}

export function getErrorSummaryItems (req, res, next) {
  const { issue_type: issueType, issue_field: issueField } = req.params
  const { entryIssues, issues: entityIssues, issueCount, entities, resources } = req

  const issues = entityIssues || entryIssues

  const totalRecordCount = entities ? entities.length : resources[0].entry_count
  const totalIssues = issueCount?.count || issues.length

  const errorHeading = ''
  const issueItems = [{
    html: performanceDbApi.getTaskMessage({ issue_type: issueType, num_issues: totalIssues, rowCount: totalRecordCount, field: issueField }, true)
  }]

  req.errorSummary = {
    heading: errorHeading,
    items: issueItems
  }

  next()
}

export function getIssueSpecification (req, res, next) {
  const { issue_field: issueField } = req.params
  const { specification } = req

  if (specification &amp;&amp; isFeatureEnabled('issueSpecificationGuidance')) {
    const fieldSpecification = specification.fields.find(f => f.field === issueField)
    req.issueSpecification = fieldSpecification
  }

  next()
}

export const prepareIssueDetailsTemplateParams = (req, res, next) => {
  const { entry, pagination, dataRange, errorSummary, dataset, orgInfo } = req
  const { issue_type: issueType, issue_field: issueField, pageNumber } = req.parsedParams

  // schema: OrgIssueDetails
  req.templateParams = {
    organisation: orgInfo,
    dataset,
    errorSummary,
    entry,
    issueType,
    issueField,
    pagination,
    pageNumber,
    dataRange
  }

  next()
}

export const fetchEndpointSummary = fetchMany({
  query: ({ params }) => {
    const datasetClause = params.dataset ? `AND dataset = '${params.dataset}'` : ''

    return `
      SELECT * FROM endpoint_dataset_summary
      WHERE organisation = '${params.lpa}'
      AND end_date = ''
      ${datasetClause}
    `
  },
  result: 'endpoints',
  dataset: FetchOptions.performanceDb
})
export const validateOrgAndDatasetQueryParams = validateQueryParams({
  schema: v.object({
    lpa: v.string(),
    dataset: v.string()
  })
})

export const fetchSources = fetchMany({
  query: ({ params }) => `
    WITH RankedEndpoints AS (
      SELECT
        rhe.endpoint,
        rhe.endpoint_url,
        case
            when rhe.status = '' or rhe.status is null then null
            else cast(rhe.status as int)
        end as status,
        rhe.exception,
        rhe.resource,
        rhe.latest_log_entry_date,
        rhe.endpoint_entry_date,
        rhe.endpoint_end_date,
        rhe.resource_start_date as resource_start_date,
        rhe.resource_end_date,
        s.documentation_url,
        ROW_NUMBER() OVER (
          PARTITION BY rhe.endpoint_url
          ORDER BY
            rhe.latest_log_entry_date DESC
        ) AS row_num
      FROM
        reporting_historic_endpoints rhe
        LEFT JOIN source s ON rhe.endpoint = s.endpoint
      WHERE
        REPLACE(rhe.organisation, '-eng', '') = '${params.lpa}'
        AND rhe.pipeline = '${params.dataset}'
        AND (
          rhe.resource_end_date >= current_timestamp
          OR rhe.resource_end_date IS NULL
          OR rhe.resource_end_date = ''
        )
        AND (
          rhe.endpoint_end_date >= current_timestamp
          OR rhe.endpoint_end_date IS NULL
          OR rhe.endpoint_end_date = ''
        )
    )
    SELECT
      endpoint,
      endpoint_url,
      status,
      exception,
      resource,
      latest_log_entry_date,
      endpoint_entry_date,
      endpoint_end_date,
      resource_start_date,
      resource_end_date,
      documentation_url
    FROM
      RankedEndpoints
    WHERE
      row_num = 1
    ORDER BY
      latest_log_entry_date DESC;
  `,
  result: 'sources'
})

export const noIndexHeader = (req, res, next) => {
  res.set('X-Robots-Tag', 'noindex')
  next()
}

/**
 * Middleware. Prevents indexing of certain pages
 *
 * @param req
 * @param res
 * @param next
 */
export const preventIndexing = (req, res, next) => {
  if (/^\/organisations\/[\w-:]+\/.*$|^\/check\/status.*$|\/check\/results.*$/.test(req.originalUrl)) {
    return noIndexHeader(req, res, next)
  }
  next()
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CheckDeepLinkController.html">CheckDeepLinkController</a></li><li><a href="EndpointSubmissionFormDeepLinkController.html">EndpointSubmissionFormDeepLinkController</a></li><li><a href="MiddlewareError.html">MiddlewareError</a></li><li><a href="PageController.html">PageController</a></li><li><a href="module.html#.exports">exports</a></li></ul><h3>Global</h3><ul><li><a href="global.html#FetchOneFallbackPolicy">FetchOneFallbackPolicy</a></li><li><a href="global.html#addNoticesToDatasets">addNoticesToDatasets</a></li><li><a href="global.html#attachFileToIssue">attachFileToIssue</a></li><li><a href="global.html#availableDatasets">availableDatasets</a></li><li><a href="global.html#checkToolDeepLink">checkToolDeepLink</a></li><li><a href="global.html#createCustomerRequest">createCustomerRequest</a></li><li><a href="global.html#datasetStatusEnum">datasetStatusEnum</a></li><li><a href="global.html#datasetSubmissionDeadlineCheck">datasetSubmissionDeadlineCheck</a></li><li><a href="global.html#datasets">datasets</a></li><li><a href="global.html#endpointSubmissionFormToolDeepLink">endpointSubmissionFormToolDeepLink</a></li><li><a href="global.html#fetchDatasetErrorStatus">fetchDatasetErrorStatus</a></li><li><a href="global.html#fetchIf">fetchIf</a></li><li><a href="global.html#fetchIfFn">fetchIfFn</a></li><li><a href="global.html#fetchLatestResource">fetchLatestResource</a></li><li><a href="global.html#fetchLocalAuthorities">fetchLocalAuthorities</a></li><li><a href="global.html#fetchMany">fetchMany</a></li><li><a href="global.html#fetchManyFn">fetchManyFn</a></li><li><a href="global.html#fetchManyFromAllDatasets">fetchManyFromAllDatasets</a></li><li><a href="global.html#fetchManyFromAllDatasetsFn">fetchManyFromAllDatasetsFn</a></li><li><a href="global.html#fetchOne">fetchOne</a></li><li><a href="global.html#fetchOneFn">fetchOneFn</a></li><li><a href="global.html#fetchOneFromAllDatasets">fetchOneFromAllDatasets</a></li><li><a href="global.html#fetchResourceStatus">fetchResourceStatus</a></li><li><a href="global.html#formatData">formatData</a></li><li><a href="global.html#getColumnFieldLog">getColumnFieldLog</a></li><li><a href="global.html#getDeadlineHistory">getDeadlineHistory</a></li><li><a href="global.html#getErrorSummary">getErrorSummary</a></li><li><a href="global.html#getGeometries">getGeometries</a></li><li><a href="global.html#getIssueDetails">getIssueDetails</a></li><li><a href="global.html#getIssueField">getIssueField</a></li><li><a href="global.html#getLastPage">getLastPage</a></li><li><a href="global.html#getPagination">getPagination</a></li><li><a href="global.html#getRowsWithVerboseColumns">getRowsWithVerboseColumns</a></li><li><a href="global.html#getSetDataRange">getSetDataRange</a></li><li><a href="global.html#getStatusTag">getStatusTag</a></li><li><a href="global.html#getVerboseColumns">getVerboseColumns</a></li><li><a href="global.html#handleRejections">handleRejections</a></li><li><a href="global.html#initiateJsHiddenChecks">initiateJsHiddenChecks</a></li><li><a href="global.html#invalidSchemaPaths">invalidSchemaPaths</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#isResourceIdValid">isResourceIdValid</a></li><li><a href="global.html#logPageError">logPageError</a></li><li><a href="global.html#lpaOverviewQuery">lpaOverviewQuery</a></li><li><a href="global.html#makeDatasetSlugToReadableNameFilter">makeDatasetSlugToReadableNameFilter</a></li><li><a href="global.html#maybeSetReferrer">maybeSetReferrer</a></li><li><a href="global.html#orgStatsReducer">orgStatsReducer</a></li><li><a href="global.html#pagination">pagination</a></li><li><a href="global.html#parallel">parallel</a></li><li><a href="global.html#parallelFn">parallelFn</a></li><li><a href="global.html#postRequest">postRequest</a></li><li><a href="global.html#prepareDatasetEndpointIssueTemplateParams">prepareDatasetEndpointIssueTemplateParams</a></li><li><a href="global.html#prepareDatasetOverviewTemplateParams">prepareDatasetOverviewTemplateParams</a></li><li><a href="global.html#prepareDatasetTaskListTemplateParams">prepareDatasetTaskListTemplateParams</a></li><li><a href="global.html#prepareGetOrganisationsTemplateParams">prepareGetOrganisationsTemplateParams</a></li><li><a href="global.html#prepareOverviewTemplateParams">prepareOverviewTemplateParams</a></li><li><a href="global.html#prepareTasks">prepareTasks</a></li><li><a href="global.html#preventIndexing">preventIndexing</a></li><li><a href="global.html#processEntitiesMiddleware">processEntitiesMiddleware</a></li><li><a href="global.html#processSpecificationMiddleware">processSpecificationMiddleware</a></li><li><a href="global.html#proto">proto</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#renderTemplate">renderTemplate</a></li><li><a href="global.html#renderTemplateFn">renderTemplateFn</a></li><li><a href="global.html#requiredDatasets">requiredDatasets</a></li><li><a href="global.html#requiresGeometryTypeToBeSelected">requiresGeometryTypeToBeSelected</a></li><li><a href="global.html#requiresGeometryTypeToBeSelectedViaDeepLink">requiresGeometryTypeToBeSelectedViaDeepLink</a></li><li><a href="global.html#schemaIssues">schemaIssues</a></li><li><a href="global.html#setNoticesFromSourceKey">setNoticesFromSourceKey</a></li><li><a href="global.html#setupNunjucks">setupNunjucks</a></li><li><a href="global.html#splitByLeading">splitByLeading</a></li><li><a href="global.html#statusToTagClassMapping">statusToTagClassMapping</a></li><li><a href="global.html#templateSchema">templateSchema</a></li><li><a href="global.html#types">types</a></li><li><a href="global.html#validateAndRender">validateAndRender</a></li><li><a href="global.html#validateQueryParamsFn">validateQueryParamsFn</a></li><li><a href="global.html#validationErrorMessage">validationErrorMessage</a></li><li><a href="global.html#wizardBackLink">wizardBackLink</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
